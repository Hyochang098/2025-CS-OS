# 04-2 레지스터

## 📌 학습 목표
- 해당 챕터의 개념 정리

## ❓ 확인 문제
### Q1. 다음 중 레지스터(Register)의 역할에 대한 설명으로 옳지 않은 것은 무엇인가요?

1️. 레지스터는 CPU 내부에 위치한 고속 임시 저장소로, 연산에 필요한 데이터를 저장합니다.

2️. 레지스터는 프로그램 카운터, 명령어 레지스터 등 중요한 제어 정보를 저장하는 역할을 합니다.

3️. 레지스터는 메모리 외부에 위치하며, 주기억장치(RAM)의 데이터 접근 속도를 보완합니다.

4️. 레지스터는 CPU의 연산속도를 높이기 위해 메모리보다 빠른 접근속도를 제공합니다.

<details>
<summary>정답</summary>

- **3️. 레지스터는 메모리 외부에 위치하며, 주기억장치(RAM)의 데이터 접근 속도를 보완합니다. X**   
  - 레지스터는 CPU 내부에 존재하며, 주기억장치(RAM)와는 구분됩니다.
  - RAM은 CPU 외부의 보조 기억장치로, 속도가 레지스터에 비해 느립니다.

**[해설]**

- **1. 레지스터는 CPU 내부에 위치한 고속 임시 저장소로, 연산에 필요한 데이터를 저장합니다.**   
  - 연산 중 필요한 데이터를 **임시로 저장**해 빠른 접근과 연산을 가능하게 합니다.

- **2. 레지스터는 프로그램 카운터, 명령어 레지스터 등 중요한 제어 정보를 저장하는 역할을 합니다.**   
  - 프로그램 카운터, 명령어 레지스터 등은 CPU 제어에 필수적인 정보를 보관합니다
  
- **4. 레지스터는 CPU의 연산속도를 높이기 위해 메모리보다 빠른 접근속도를 제공합니다.**  ❌ 
  - 메모리보다 빠른 접근속도로 연산 효율성을 극대화합니다.
---

</details>


### Q2. 다음 레지스터 종류와 해당 레지스터가 수행하는 역할을 올바르게 매칭하라.

<레지스터 종류>

- 프로그램 카운터
- 명령어 레지스터
- 메모리 주소 레지스터
- 메모리 버퍼 레지스터
- 플래그 레지스터
- 범용 레지스터
- 스택 포인터
- 베이스 레지스터


< 수행 역할 >

- 메모리에서 읽어 들인 명령어를 저장한다.
- 프로그램의 가장 작은 물리 주소를 저장한다.
- 메모리에서 읽어 들일 명령어의 주소를 저장한다.
- 메모리와 주고받을 값을 저장한다.
- 다양하고 일반적인 상황에서 자유롭게 사용되며, 데이터와 주소를 모두 저장할 수 있다.
- 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장한다.
- 메모리의 주소를 저장한다.
- 스택에 마지막으로 저장한 값의 위치를 저장한다. 

<details>
<summary>정답</summary>

| 연산 코드 유형 | 수행 역할 |
|--------------|--------------------------|
| **1. 프로그램 카운터** | 메모리에서 읽어 들일 명령어의 주소를 저장한다. |
| **2. 명령어 레지스터** | 메모리에서 읽어 들인 명령어를 저장한다. |
| **3. 메모리 주소 레지스터** | 메모리의 주소를 저장한다. |
| **4. 메모리 버퍼 레지스터** | 메모리와 주고받을 값을 저장한다. |
| **5. 플래그 레지스터** | 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장한다. |
| **6. 범용 레지스터** | 다양하고 일반적인 상황에서 자유롭게 사용되며, 데이터와 주소를 모두 저장할 수 있다. |
| **7. 스택 포인터** | 스택에 마지막으로 저장한 값의 위치를 저장한다. |
| **8. 베이스 레지스터** | 프로그램의 가장 작은 물리 주소를 저장한다. (06-1장 참고) |


---

</details>

### Q3. 프로그램 카운터(PC)와 명령어 레지스터(IR)는 어떤 역할을 하며, JAVA 프로그램 실행 과정에서 어떻게 활용될 수 있나요?

<details>
<summary>정답</summary>

- IR(명령어 레지스터): 현재 실행 중인 명령어 자체를 저장합니다.
- PC(프로그램 카운터): CPU가 실행할 다음 명령어의 메모리 주소를 저장합니다.
- IR : 오류가 발생한 명령어를 저장
```java
public class Main {
    public static void main(String[] args) {
        String text = null;
        text.length(); // NullPointerException 발생!
    }
}
```
- PC : 다음 명령어의 메모리 주소를 저장장
```java
public class PCExample {
    public static void main(String[] args) {
        int a = 10;  //다음 명령어 주소를 저장
        int b = 20;  // 다음 실행할 코드의 메모리 주소 저장
        int sum = add(a, b); // PC가 add() 메서드의 첫 줄 주소를 저장
        System.out.println("Result: " + sum); // add() 실행 후, PC가 이 줄의 주소를 저장
    }

    public static int add(int x, int y) {
        return x + y;  // 메서드가 끝난 후 돌아올 주소를 저장
    }
}


```
- Java에서의 활용: JVM은 바이트코드를 실행할 때 PC 레지스터를 사용하여 실행 흐름을 관리합니다. Java 예외 발생 시, Stack Trace를 통해 실행 위치를 추적 가능합니다.

</details>

### Q4. 변위 주소 지정 방식에서 상대 주소 지정 방식과 베이스 레지스터 주소 지정 방식의 차이점은?

<details>
<summary>정답</summary>

#### **베이스 레지스터 주소 지정 방식**
- 특정 **베이스 레지스터**를 기준으로, **오프셋**(기준에서 상대적인 주소)을 더해 **실제 메모리 주소를 결정하는 방식**입니다.  
- 주로 **운영체제의 메모리 보호 및 다중 프로세스 환경**에서 유용하며, 프로그램이 메모리 내에서 **유연하게 실행**될 수 있도록 합니다.  

#### **상대 주소 지정 방식**
- 현재 실행 중인 **프로그램 카운터의 값**에 **오프셋을 더한 메모리 주소**를 계산하는 방식입니다.  
- **조건문이나 반복문**에서 실행 흐름을 조정할 때 많이 사용됩니다.  

---

#### 베이스 주소 지정 방식이 적합한 경우
- **운영체제**가 각 프로세스에 **독립적인 메모리를 할당**해야 할 때  
- **동적 메모리 할당이 필요**한 프로그램 (예: 가상 메모리, 멀티 프로세스 환경 등)

#### **상대 주소 지정 방식이 적합한 경우**
- 반복문 실행 중 **특정 조건에서 빠져나올 때**
- 명령문, 조건문을 명령어를 활용해 **코드 실행 흐름을 제어**할 때  

---

### **결론**
> - 베이스 주소 지정 방식은 **운영체제의 메모리 관리**에 유용  
> - 상대 주소 지정 방식은 **실행 흐름을 제어**하는 데 적합 

</details>

### Q5. 다음 중 베이스 레지스터(Base Register) 주소 지정 방식의 특징으로 올바른 것은?

**1️⃣** **프로그램이 실행되는 위치가 변경될 경우, 명령어를 수정해야 한다.**

**2️⃣** **프로그램이 실행되는 위치가 변경되어도 베이스 레지스터 값만 변경하면 정상적으로 실행할 수 있다.**

**3️⃣** **베이스 레지스터를 사용하면 프로그램 크기를 변경할 수 없다.**

**4️⃣** **베이스 레지스터는 항상 고정된 값을 가지고 있으며, 변경할 수 없다.**

<details>
<summary>정답</summary>

**2️⃣** **프로그램이 실행되는 위치가 변경되어도 베이스 레지스터 값만 변경하면 정상적으로 실행할 수 있다.**

**[해설]**

**베이스 레지스터(Base Register) 주소 지정 방식**
- 명령어 안에 있는 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방법
- 핵심은 프로그램을 실행할 때 물리적 위치가 바뀌더라도 그에 해당하는 베이스 레지스터의 값만 변경하면 정상적으로 실행이 가능함!

**1️⃣** **프로그램이 실행되는 위치가 변경될 경우, 명령어를 수정해야 한다.**<br>
-> 베이스 레지스터 주소 지정 방식에서는 명령어 자체를 수정할 필요가 없으며, 프로그램이 실행되는 위치가 변경되면 **베이스 레지스터**의 값을 수정해야 한다.

**3️⃣** **베이스 레지스터를 사용하면 프로그램 크기를 변경할 수 없다.**<br>
-> 베이스 레지스터 방식은 메모리 내에서 프로그램이 이동될 수 있도록 설계된 방식이지만,
프로그램 크기 변경과는 직접적인 관계가 없음.

**4️⃣** **베이스 레지스터는 항상 고정된 값을 가지고 있으며, 변경할 수 없다.**<br>
-> 베이스 레지스터는 운영체제가 프로그램을 실행할 때마다 값이 바뀐다.<br>
-> ex) 프로그램 1000번지 로드 --> 베이스 레지스터 값 = 1000<br>
프로그램 2000번지 로드 --> 베이스 레지스터 값 = 2000


---

</details>

### Q6. 다음 중 아래에서 설명하는 주소 지정 방식에 해당하는 것은?
- 메모리 내부의 스택 영역과 스택에 마지막으로 저장한 데이터의 위치를 저장하는 스택 포인터를 이용한 주소 지정 방식
- 스택 포인터가 스택에 데이터가 꺼내지거나 채워지는 경우에 맞게 변경되며, 스택 포인터가 가리키는 값에 접근할 수 있다.

#### 1️⃣ 상대 주소 지정 방식
#### 2️⃣ 베이스 레지스터 주소 지정 방식
#### 3️⃣ 스택 주소 지정 방식
#### 4️⃣ 즉시 주소 지정 방식

<details>
<summary>정답</summary>

#### 3️⃣ 스택 주소 지정 방식

- 상대 주소 지정 방식 : 오퍼랜드와 프로그램 카운더의 값을 더하여 유효 주소를 얻는 방식
- 베이스 레지스터 주소 시정 방식 : 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식
- 즉시 주소 지정 방식 : 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식

---

</details>

### Q7. 음성인식 프로그램이 있다. 외국인이 와서 말을 하다가 프로그램의 순차적인 흐름이 끊겨겨버렸다.
### 외국인의 말 중 프로그램의 순차적인 흐름을 끊어 버린 키워드는?


 Hey! I'm @$*#(##(#))  "Stop"  #$&#%(*%@)$(@)@*$"Fast"
 (#*&%(&##))  "JUMP" #%#(*#@)$##(*#(##)) "Again"

<details>

<summary>정답</summary>

- #### 2️⃣ JUMP 
  - 점프 뒤에 숫자가 있다면 프로그램은 그 숫자에 해당하는 메모리 주소로 점프한다. 
  그 외의 순차적인 흐름을 끊는 명령어로는 CONDITIONAL JUMP,CALL,RET 등이 있다.

  
---

</details>

### Q8. 다음 중 스택 주소 지정 방식이 실제로 활용되는 경우가 아닌 것은?

#### 1️⃣ 재귀 호출
#### 2️⃣ 하드웨어 인터럽트 처리
#### 3️⃣ 후위 표기법(postfix) 계산
#### 4️⃣ 분기문을 활용한 실행 흐름 제어

<details>
<summary>정답</summary>

<h4>4️⃣ 분기문을 활용한 실행 흐름 제어</h4>

- 분기문을 활용한 실행 흐름 제어는 특정 라인의 코드로 이동해야 함
- 이 때, 프로그램 카운터와 오프셋 값(오퍼랜드)을 더해 유효 주소를 구하는 상대 주소 지정 방식이 활용되므로 4번이 정답

---
*나머지 선지의 실행 흐름 대강 살펴보기*

1️⃣ 재귀 호출
	- 함수 내부에서 자기 자신을 호출할 때마다 스택에 담기
	- 탈출 조건에 도달하면 처리 완료 후, 하나의 호출씩 거슬러 올라감
		- 이 때, 조건에 따라 파라미터를 바꿔가면서 호출하는 경우 다시 자기 자신을 호출하고 스택에 담을 수 있음
	- 제일 처음 호출된 함수에 도달하면 종료

2️⃣ 하드웨어 인터럽트 처리
	- 입출력장치에서 인터럽트 요청 신호를 보냄
	- CPU가 인터럽트를 받아들일 수 있는 상황 혹은 무시할 수 없는 인터럽트 요청 신호가 발생하면 지금까지 작업을 백업
		- 이 때 프로그램 카운터에 있는 값을 스택에 저장
	- 인터럽트 서비스 루틴을 실행
	- 실행 완료 후, 스택에 있는 값을 다시 프로그램 카운터로 가져가 기존 작업 진행

3️⃣ 후위 표기법(postfix) 계산
	- 식을 읽어 가며 피연산자는 스택에
	- 연산자를 만나면 두 개의 피연산자를 꺼냄
	- 연산이 끝나면 연산 결과를 다시 스택에
	- 식 끝까지 읽은 뒤, 하나의 값이 스택에 남아있다면 연산 완료
		- 꺼내서 활용하면 됨

</details>

### Q9. 순차적인 실행 흐름이 끊기는 경우는?

<details>
<summary>정답</summary>

<h4>특정 메모리 주소로 실행 흐름을 이동하는 명령어가 실행될 때, 인터럽트가 발생했을 때</h4>

- 일반적으로 프로그램 카운터는 꾸준히 증가하기 때문에 프로그램 실행 흐름은 순차적임.
- 그러나 실행 흐름 이동 명령어 실행 혹은 인터럽트 발생 시에는 프로그램 카운터에 특정한 메모리 주소가 전달되기 때문에 순차적인 실행 흐름이 끊긴다.
	- 프로그램 카운터에 특정한 메모리 주소가 전달될 때, 전달받은 값을 그냥 덮어쓰면 기존에 진행 중이던 작업으로 돌아갈 수 없기 때문에 스택에 원래 담겨있던 값을 저장한다.

</details>

### Q10. x86 CPU에서 IP(Instruction Pointer, 명령어 포인터)는 프로그램 카운터에 해당하는 레지스터가 아니다 \[O, X]

<details>
<summary>정답</summary>

<h4>X</h4>

- CPU 레지스터는 사실 어떤 회사에 의해 상용화 되느냐에 따라 이름과 구조가 달라질 수 있다. ARM CPU와 x86 CPU는 각각 특성에 맞는 레지스터를 보유하고 있으며 x86 CPU의 경우, 16bit, 32bit, 64bit의 워크를 지원하는 CPU 마다 같은 기능을 하는 레지스터의 이름이 각기 다르다
- x86 CPU의 IP는 프로그램 카운터 역할을 하고 있으며 16bit에서는 IP, 32bit에서는 EIP, 64bit에서는 RIP라는 이름을 사용한다

- [참고_교재에 첨부되어 있는 링크](https://github.com/kangtegong/self-learning-cs/blob/main/registers/registers.md#%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-arm-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0)
	- 여기 가면 각각의 상용 CPU의 레지스터 구조에 관한 설명이 실려있음

</details>

### Q10. CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 버퍼 레지스터를 거친다. (O/X)


<details>
<summary>정답</summary>

- X : CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼때는 메모리 주소 레지스터를 거친다.
- 메모리 버퍼 레지스터 : CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고 받을 값은 메모리 버퍼 레지스터를 거친다.

</details>

### Q11. CPU 내부 레지스터 중에서 연산 결과를 저장하고, 이후 연산에서 활용할 수 있는 레지스터는 무엇인가?
#### 1️⃣ 프로그램 카운터(PC)
#### 2️⃣ 명령어 레지스터(IR)
#### 3️⃣ 범용 레지스터(General Purpose Register)
#### 4️⃣ 메모리 주소 레지스터(MAR)

<details>
<summary>정답</summary>

#### 3️⃣ 범용 레지스터(General Purpose Register)


- 범용 레지스터(GPR, General Purpose Register)는 특정한 목적 없이 다양한 연산을 수행할 때 임시 데이터 저장에 사용됨.
- 예를 들어, ALU에서 수행한 연산 결과를 저장하고, 이후 연산에서 다시 사용할 수 있음.
- 반면, PC(프로그램 카운터)는 다음 실행할 명령어의 주소 저장.
- IR(명령어 레지스터)는 현재 실행 중인 명령어 저장.
- MAR(메모리 주소 레지스터)는 메모리에서 읽거나 쓸 데이터의 주소 저장.

</details>

### Q12. 현재 PC가 0x1503이고, 오퍼랜드가 -7이 실행되었을 때의 주소는? 

#### 1️⃣ 0x14FA
#### 2️⃣ 0x1500
#### 3️⃣ 0x14FC
#### 4️⃣ 0x14FE

<details>
<summary>정답</summary>

#### 3️⃣ : 0x14FC (0x1503 - 7 = 0x14FC)
- 상대 주소 지정 방식(Relative Addressing Mode)은 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식(EA = PC + A)
- PC가 자동으로 참조되고 명령어에 전체 주소를 포함할 필요가 없어 주소 비트를 절약할 수 있음
- 지역성 개념을 활용하여 대부분 기억 장치의 참조들이 현재 실행되고 있는 명령어에 인접한 부분 참조

---

</details>

### Q13. 다음 중 **프로그램 카운터(PC)**가 실행 중인 명령어의 다음 번지 주소가 아닌 **전혀 다른 값으로 업데이트되는 경우가 아닌 것**는?
#### 1️⃣ 프로그램이 JMP 0x00400020 명령어를 실행하여 특정 메모리 주소로 이동하는 경우
#### 2️⃣ CALL function 명령어를 실행하여 서브루틴(함수)로 분기하는 경우
#### 3️⃣ ADD R1, R2, R3 명령어를 실행하여 두 레지스터 값을 더하는 경우
#### 4️⃣ 0으로 나누기를 수행하여 CPU가 예외(Exception) 처리를 위해 예외 핸들러로 점프하는 경우

<details>
<summary>정답</summary>

#### 3️⃣ 단순한 산술 연산 명령어는 PC(프로그램 카운터)를 변경하지 않으며, 정상적으로 다음 명령어 주소로 증가한다.

**[해설]**
- 1️⃣ (JMP 0x00400020): 무조건 점프 명령어를 실행하면 프로그램 카운터가 해당 주소(0x00400020)로 이동한다.
- 2️⃣ (CALL function): 함수 호출 명령어를 실행하면 현재 PC 값을 저장한 후, 함수의 시작 주소로 이동한다.
- 4️⃣ (0으로 나누기 예외 발생): 잘못된 명령어 실행(0으로 나누기 등)으로 인해 CPU가 예외 핸들러를 실행하며, PC가 해당 핸들러의 주소로 변경된다.

</details>

### Q14. 다음 중 범용 레지스터가 대체하기 불가능한 레지스터는?
#### 1️⃣ 명령어 레지스터
#### 2️⃣ 메모리 버퍼 레지스터
#### 3️⃣ 메모리 주소 레지스터
#### 4️⃣ 스택 포인터

<details>
<summary>정답</summary>

#### 1️⃣ 명령어 레지스터는 명령어를 디코딩하는 과정에서 사용되며, 특정한 제어 논리가 포함되기 때문에 범용 레지스터가 이를 대체할 수 없다. 
**[해설]**
- 메모리 버퍼 레지스터, 메모리 주소 레지스터, 스택 포인터의 역할은 범용 레지스터가 제한적으로 수행할 수 있다. 

</details>

## 📝 사용법  
### 이렇게 활용해 보세요! ✨  
1. ❓ 확인 문제 아래에 본인이 만든 질문을 추가하세요.  
2. 설명이 길어질 경우, 따로 마크다운 파일을 만들고 링크를 함께 추가해 주세요! 🔗  

### 🔗 링크 추가 방법  
1. 먼저 질문을 작성합니다.  
2. 링크를 적용할 문장을 마우스로 선택합니다.  
3. URL을 붙여넣습니다.  
4. 마크다운 형식으로 `[내용](링크)` 형태로 정리됩니다.  
