# 04-3 명령어 사이클과 인터럽트

## 📌 학습 목표
- 해당 챕터의 개념 정리

## ❓ 확인 문제
### Q1. 인터럽트(Interrupt)가 발생하는 이유로 가장 적절한 것은 무엇인가요?

1️. CPU가 명령어를 더 빨리 실행하기 위해

2️. 메모리가 부족해서 데이터를 삭제하기 위해

3️. 프로그램을 더 빠르게 실행하기 위해

4. 입출력 장치나 시스템 오류 등이 발생했을 때 CPU의 작업을 잠시 멈추고 처리하기 위해

<details>
<summary>정답</summary>

- **4️. 입출력 장치나 시스템 오류 등이 발생했을 때 CPU의 작업을 잠시 멈추고 처리하기 위해.**   
  - 입출력 장치의 요청, 키보드 입력, 소프트웨어 예외(예: 0으로 나누기 오류) 등이 발생하면 CPU는 현재 작업을 중단하고, 해당 요청을 우선 처리합니다
  - 예를 들어, 프린터가 인쇄를 완료하면 CPU는 인터럽트를 받아 다음 인쇄 작업을 시작합니다.

**[해설]**

- **인터럽트(Interrupt)**
	- CPU가 특정 작업을 수행 중일 때 긴급한 사건이 발생하면 현재 작업을 멈추고 먼저 처리하도록 하는 기능



- **1.  CPU가 명령어를 더 빨리 실행하기 위해**   
  - 인터럽트는 메모리 공간을 확보하는 기능 X
  - 메모리가 부족할 경우, 컴퓨터는 다른 방법으로 공간을 확보하지만, 이 과정에서 인터럽트가 꼭 필요한 것은 아닙니다.


- **2. 메모리가 부족해서 데이터를 삭제하기 위해**   
  - 메모리 부족은 일반적으로 가상 메모리 기법(Paging, Swapping)으로 해결됩니다.
  - 인터럽트는 메모리 관리와 직접적인 연관이 없습니다
  

- **3. 프로그램을 더 빠르게 실행하기 위해** 
  - 오히려 인터럽트가 많아지면 프로그램 실행 속도가 느려질 수 있습니다.
  - 인터럽트는 긴급한 이벤트를 먼저 처리하는 기능이지, CPU 속도를 증가시키는 기능이 아닙니다.
  
---

</details>

### Q2. CPU의 작업을 방해하는 신호인 인터럽트 중 다음의 하드웨어 인터럽트 처리 순서를 올바르게 나열하시오.

1. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
2. 인터럽트 서비스 루틴 실행이 끝나면 백업해 둔 작업을 복구하여 실행을 재개한다. 
3. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
4. 입출력장치는 CPU에 인터럽트 요청 신호를 보낸다.
5. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
6. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다.

<details>
<summary>정답</summary>

(4) -> (5) -> (1) -> (3) -> (6) -> (2)

**[해설]**

인터럽트(Interrupt)는 **CPU가 실행 중인 작업을 일시적으로 중단하고, 특정 이벤트(예: 입출력 완료, 타이머 이벤트, 오류 발생 등)를 처리하기 위해 실행되는 메커니즘**이다.  
인터럽트는 **동기 인터럽트**와 **비동기 인터럽트(하드웨어 인터럽트)**로 나뉘며, 이 문제에서는 **하드웨어 인터럽트의 처리 과정**을 다룬다.  

---

### **🔹 인터럽트 처리 과정 상세 설명**  

1️⃣ **(4) 입출력장치는 CPU에 인터럽트 요청 신호를 보낸다.**  
   - 키보드 입력, 디스크 입출력, 네트워크 이벤트 등 **외부 장치(입출력 장치)가 CPU에 인터럽트 요청(Interrupt Request, IRQ) 신호를 보낸다.**  
   - 이 신호는 **인터럽트 컨트롤러**를 통해 CPU에 전달된다.  

2️⃣ **(5) CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.**  
   - CPU는 **명령어 실행이 끝난 후** 새로운 명령어를 가져오기 전에 **인터럽트 요청이 있는지 확인**한다.  
   - 만약 인터럽트가 있다면, 현재 실행 중인 프로세스를 일시 중단하고 인터럽트를 처리한다.  

3️⃣ **(1) CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.**  
   - CPU는 **인터럽트 가능 여부(플래그 상태)와 인터럽트 우선순위(다른 인터럽트와의 비교)**를 확인한다.  
   - 만약 현재 인터럽트를 처리할 수 없다면, 요청을 보류하고 기존 작업을 계속 진행한다.  

4️⃣ **(3) 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.**  
   - 현재 실행 중이던 명령어의 **레지스터 값, 프로그램 카운터(PC), 플래그 레지스터** 등을 **스택(Stack)에 저장하여 나중에 복구할 수 있도록 한다.**  
   - 이렇게 하면 인터럽트 처리가 끝난 후 원래 작업으로 복귀할 수 있다.  

5️⃣ **(6) CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다.**  
   - CPU는 **인터럽트 벡터 테이블(Interrupt Vector Table, IVT)을 참조하여 해당 인터럽트에 맞는 인터럽트 서비스 루틴(ISR, Interrupt Service Routine)을 실행한다.**  
   - ISR은 **해당 인터럽트 요청을 처리하는 코드(예: 키보드 입력 처리, 네트워크 패킷 수신 처리 등)이다.**  

6️⃣ **(2) 인터럽트 서비스 루틴 실행이 끝나면 백업해 둔 작업을 복구하여 실행을 재개한다.**  
   - 인터럽트 처리가 완료되면, **스택에 저장해 둔 레지스터와 프로그램 카운터(PC) 값을 복원하여 원래 실행하던 프로그램으로 돌아간다.**  
   - 이후 CPU는 중단되었던 작업을 다시 수행한다.  

  ---

</details>

### Q3. 인터럽트의 종류에 대한 설명으로 가장 적절한 것은 무엇인가요?  


#### 1️⃣ 동기 인터럽트는 외부 하드웨어 장치에서 발생하는 인터럽트이다.  
#### 2️⃣ 비동기 인터럽트는 소프트웨어적인 예외나 시스템 호출에 의해 발생한다.  
#### 3️⃣ 하드웨어 인터럽트는 프로세서 내부에서 발생하는 인터럽트이다.  
#### 4️⃣ 동기 인터럽트는 프로그램의 실행 흐름과 관련이 있으며, 명령어 실행 중 발생할 수 있다.  

<details>
<summary>정답</summary>

- #### 4️⃣ 동기 인터럽트는 프로그램의 실행 흐름과 관련이 있으며, 명령어 실행 중 발생할 수 있다. 
  - 동기 인터럽트는 프로그램 실행 중 발생하는 예외나 시스템 호출 등의 원인으로 발생합니다.  
#### 소프트웨어 인터럽트 
- **소프트웨어에서 실행 중 발생**하는 인터럽트.
- **예:**  
  - `System Call`= 운영체제의 기능을 사용하기 위한 요청
  - `Exception` = 예외 처리

---

### **인터럽트의 종류**  
인터럽트는 크게 **동기 인터럽트**와 **비동기 인터럽트**로 구분됩니다.  

#### **1️⃣ 동기 인터럽트 **
- 프로그램의 **명령어 실행 중 발생**하는 인터럽트로, 실행 흐름과 관련이 있음.
- **발생 원인:**  
  - 0으로 나누기
  - 잘못된 메모리 접근 
  - 시스템 호출  

#### **2️⃣ 비동기 인터럽트 **
- 프로그램의 실행과는 **독립적으로 발생**하는 인터럽트.
- **발생 원인:**  
  - 키보드 입력 (`Keyboard Interrupt`)  
  - 네트워크 패킷 도착  
  - 타이머 인터럽트 (`Timer Interrupt`)  

#### **3️⃣ 하드웨어 인터럽트 **
- **외부 장치**에서 발생하며, 비동기 인터럽트에 해당함.


---

### **자바의 인터럽트 **
- `interrupt()`  
> - **작업이 오래 걸리는 스레드**를 안전하게 종료해야 할 때 활용
> - 무한 루프를 실행 중인 스레드를 종료할 때 사용
- `isInterrupted()`
> - 스레드가 중단 요청을 받았는지 확인
> - **여러 번 인터럽트를 확인**해야 하는 반복 작업 시 사용
- `Thread.interrupted()`
> - 현재 실행 중인 스레드가 인터럽트를 받았는지 확인하고, 즉시 플래그를 초기화
> - **한 번만 인터럽트를 체크**해야 하는 경우 사용
> - 인터럽트 플래그를 **초기화**


---

</details>


### Q4. 인터럽트 벡터 테이블(IVT)에 저장되는 정보는 무엇인가?

<details>
<summary>정답</summary>

 인터럽트 벡터 테이블(IVT, Interrupt Vector Table)에는 **각 인터럽트 번호(Interrupt Number)** 와 해당 인터럽트를 처리할 ISR(인터럽트 서비스 루틴)의 주소가 저장되어 있다.<br>
CPU는 인터럽트가 발생하면 인터럽트 벡터 테이블을 참조하여 ISR의 주소를 찾아 실행한다.

</details>

### Q5. 하드웨어 인터럽트는 CPU 입출력 작업 도중에도 효율적으로 명령어 처리를 하기 위해 사용된다. 하드웨어 인터럽트가 효율적인 명령어 처리를 가능하게 하는 이유는 무엇인가?

<details>
<summary>정답</summary>

- 만약 하드웨어 인터럽트를 사용하지 않는다면, CPU가 하드웨어에 명령한 작업 완료 여부를 확인하기 위한 주기적인 비용이 필요하다. 이는 CPU의 작업을 방해하는 CPU 사이클 낭비 요소로 볼 수 있다.

- 하지만 하드웨어 인터럽트를 이용하면 CPU가 주기적으로 완료 여부를 확인하지 않고,  작업 완료 시 입력 알림 즉 인터럽트를 받아 그전까지 다른 작업을 처리할 수 있다.

- 이러한 이유로 하드웨어 인터럽트를 사용하면 그렇지 않은 경우와 비교했을 때, 효율적인 명령어 처리가 가능하게 된다.

---

</details>

### Q6. 학생 HJS가 사망한 채로 발견되었다 사체 주변에는 다잉메시지가 남겨져있다.
### "예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어의 다음 명령어 부터 실행을 재개하는 예외"
### 다잉 메시지를 보고 추측할 수 있는 범인은 누구인가?  


#### 1️⃣ 폴트 
#### 2️⃣ 트랩  
#### 3️⃣ 중단  
#### 4️⃣ 소프트웨어 인터랩트  

<details>
<summary>정답</summary>

- #### 2️⃣ 트랩 
  - 트랩은 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어의 다음 명령어 부터 실행을 재개하는 예외이다.  
  - 교재에서는 디버깅이이 대표적인 트랩의 예라고 합니다. 

**[해설]**

- **1  폴트는 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외.**  ❌ 
  -  명령어를 실행시키기 위해 보조 기억장치에 데이터를 자져와야 하는 상황을 예로 들고 있습니다. 

- **3  중단은 CPU가 실행 중인 프로그램을 강제로 중단 시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외외.**  ❌ 
 
  
- **4  소프트웨어 인터럽트는 시스템 호출이 발생할 때만 나타난다.**  ❌ 
  - 자세한 내용은 9장에서 설명한다고 교재에 서술. 
  
---

</details>

### Q7. 재귀 함수를 작성했는데 실수로 탈출 조건을 작성하지 않아 스택 오버플로우가 발생했다. 이 경우 어떤 인터럽트가 발생하는가?

<details>
<summary>정답</summary>

<h4>동기 인터럽트 중 중단이 발생한다.</h4>

- 중단(Abort)
	- CPU가 강제로 끊어야만 하는 심각한 오류

- 스택 오버플로우는 스택 메모리를 초과하는 메모리 쓰기가 감지되면 CPU가 이를 보호 예외로 처리하고 복구가 불가능 한 경우 중단 발생

</details>

### Q8. 다음 중 인터럽트 플래그에 대한 내용으로 옳지 않은 것은?

#### 1️⃣ 하드웨어 인터럽트를 받아들일지 무시할지를 결정한다.
#### 2️⃣ 플래그 레지스터의 인터럽트 플래그를 비활성화하면 모든 하드웨어 인터럽트를 무시할 수 있다.
#### 3️⃣ 인터럽트 플래그가 활성화 되어있었다면 지금까지 작업을 백업하고 ISR을 실행한다.
#### 4️⃣ 인터럽트 요청이 오면 인터럽트 플래그를 확인하여 인터럽트 처리를 결정한다

<details>
<summary>정답</summary>

<h4>2️⃣ 플래그 레지스터의 인터럽트 플래그를 비활성화하면 모든 하드웨어 인터럽트를 무시할 수 있다.</h4>

- 인터럽트 플래그가 비활성화 되어있어도 하드웨어 고장 등으로 인한 우선 순위가 높은 인터럽트 요청 신호가 오면 인터럽트를 처리 해야 함.

</details>

### Q9. 다음 중, 명령어 사이클에 관한 설명으로 옳지 않은 것은?

#### 1️⃣ 명령어 사이클이란 하나의 명령어를 처리하는 정형화된 흐름이다.
#### 2️⃣ 인출 사이클은 메모리에 처리 후의 결괏값을 전달하는 과정이다.
#### 3️⃣ 실행 사이클은 가져온 명령어를 실행하는 과정이다.
#### 4️⃣ 간접 사이클은 간접 주소 지정 방식 등으로 값이 전달되어 추가적인 메모리 접근이 필요할 때만 진행된다.

<details>
<summary>정답</summary>

<h4>2️⃣ 인출 사이클은 메모리에 처리 후의 결괏값을 전달하는 과정이다.</h4>

- 인출 사이클은 메모리로 결괏값을 전달하는 과정이 아닌 메모리에서 CPU로 명령어를 가져오는 과정이다.

</details>

### Q10. 한 게임에서 플레이어 캐릭터가 이동하는 도중, 적이 공격을 가하면 화면에 "피해를 입었습니다!"라는 메시지가 즉시 나타난다. 하지만 캐릭터 이동 로직과 적의 공격 로직은 서로 다른 루틴으로 실행되고 있다. 이때, 게임이 정상적으로 동작하기 위해 하드웨어 인터럽트는 어떤 역할을 할까? 그리고 만약 하드웨어 인터럽트가 없다면, 어떤 문제가 발생할 수 있는지 설명하라.

<details>
<summary>정답</summary>

<h4>게임에서 하드웨어 인터럽트는 적의 공격 입력(예: 키보드 입력 등)이 발생하면 즉시 CPU가 해당 이벤트를 처리하도록 개입하는 역할을 한다.</h4>

- 캐릭터 이동 루틴이 실행되고 있을 때, 적이 공격하면 인터럽트 컨트롤러가 CPU에 신호를 보냄.
- CPU는 현재 실행 중이던 캐릭터 이동 루틴을 일시 중단하고, 적의 공격 처리 루틴(예: HP 감소, 피해 애니메이션, 메시지 출력 등)으로 즉시 전환함.
- 공격 처리가 끝난 후, CPU는 원래 수행하던 캐릭터 이동 루틴으로 복귀.

</details>

### Q11. 인터럽트 서비스 루틴(ISR)이 실행된 후, CPU가 원래 수행하던 작업으로 복귀할 수 있는 이유는?
#### 1️⃣ 프로그램 카운터(PC)가 ISR의 끝부분을 자동으로 가리키기 때문이다.
#### 2️⃣ ISR 실행 중, CPU는 자동으로 원래 실행 중이던 작업을 메모리에 백업해두기 때문이다.
#### 3️⃣ CPU가 ISR 실행 전에 현재 상태를 스택(Stack)에 저장하고, ISR 종료 후 다시 복구하기 때문이다.
#### 4️⃣ ISR이 실행되면 현재 실행 중이던 프로그램은 완전히 종료되고 새로운 프로그램이 시작되기 때문이다.

<details> <summary>정답</summary>

#### 3️⃣ CPU가 ISR 실행 전에 현재 상태를 스택(Stack)에 저장하고, ISR 종료 후 다시 복구하기 때문이다.

- 인터럽트가 발생하면 CPU는 현재 실행 중인 명령어의 주소(PC), 레지스터 값, 플래그 레지스터 상태 등을 스택에 저장함.
- ISR 실행 후, CPU는 스택에서 원래 상태를 복구하고 인터럽트가 발생하기 전 명령어 다음부터 실행을 재개함.
- 반면, 1번(PC 자동 복구)는 틀림 → PC는 인터럽트 처리 후 수동 복구됨.
- 2번(CPU가 자동 백업)는 틀림 → 백업은 스택을 통해 이루어짐.
- 4번(원래 프로그램이 종료됨)는 틀림 → ISR이 실행된 후 원래 작업을 계속 수행함.

</details>


## 📝 사용법  
### 이렇게 활용해 보세요! ✨  
1. ❓ 확인 문제 아래에 본인이 만든 질문을 추가하세요.  
2. 설명이 길어질 경우, 따로 마크다운 파일을 만들고 링크를 함께 추가해 주세요! 🔗  

### 🔗 링크 추가 방법  
1. 먼저 질문을 작성합니다.  
2. 링크를 적용할 문장을 마우스로 선택합니다.  
3. URL을 붙여넣습니다.  
4. 마크다운 형식으로 `[내용](링크)` 형태로 정리됩니다.  
