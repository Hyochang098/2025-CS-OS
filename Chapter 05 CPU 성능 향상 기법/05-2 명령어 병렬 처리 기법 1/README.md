# 05-2 명령어 병렬 처리 기법 1

## 📌 학습 목표
- 해당 챕터의 개념 정리

## ❓ 확인 문제
### Q1. LG전자에 재직 중인 엘리트직원 KDU씨는 공장에서 명령어 파이프라인을   실행하였다. 하지만 명령어를 제대로 실행되지 않았다. 
###  명령어 파이프라인을 보고 어떤 파이프라인 위험이 발생했는지 작성하시오.

**명령어 1:R1 <- R2+R3**

**명령어 2:R4 <- R1+R3**

<details>
<summary>정답</summary>

- **데이터위험 **   

**[해설]**
데이터 위험은 명령어 간 데이터 의존성에 의해 발생한다. 이전 명령어를 처리해야 처리할 수 있는 명령어가 동시에 주어졌을 때 발생하는 파이프라인 위험이다.
즉 위 예시에서 명령어 2를 처리하기 위해서는 명령러 1을 먼저 처리 해야 하는데
동시에 제시됨으로서 데이터 위험이 발생한 것이다.

---

</details>

### Q2. 명령어 병렬 처리 기법에 대한 설명으로 틀린 것은?

1️. 파이프라이닝(Pipelineing)은 명령어를 여러 단계로 나누어 동시에 실행하는 방식이다.

2️. 슈퍼스칼라(Superscalar)는 여러 개의 명령어를 병렬로 처리할 수 있는 아키텍처이다.

3️. 멀티코어(Multi-core) CPU에서는 하나의 코어에서만 명령어가 실행된다.

4. 명령어 병렬 처리 기법을 활용하면 CPU의 처리 속도를 향상시킬 수 있다.

<details>
<summary>정답</summary>

- **3️. 멀티코어(Multi-core) CPU에서는 하나의 코어에서만 명령어가 실행된다. X**   
  - 멀티코어 CPU는 여러 개의 코어가 독립적으로 명령어를 실행할 수 있기 때문에, 병렬 처리를 통해 성능을 향상시킬 수 있습니다.
  - 현대의 CPU는 여러 코어를 활용하여 여러 작업(멀티태스킹)을 동시에 수행할 수 있습니다.

**[해설]**

- **파이프라이닝(Pipelineing)은 명령어를 여러 단계로 나누어 동시에 실행하는 방식이다. O**   
  - CPU에서 하나의 명령어를 여러 단계로 나누어 동시에 실행하는 기법
  - 예: 공장에서 제품을 조립할 때 여러 작업을 병렬로 수행하는 것과 유사


- **2️. 슈퍼스칼라(Superscalar)는 여러 개의 명령어를 병렬로 처리할 수 있는 아키텍처이다. O**   
  - 여러 개의 명령어를 동시에 실행할 수 있도록 설계된 CPU 구조
  - CPU 내부에 여러 개의 실행 유닛(연산 장치)이 있어 한 클럭 사이클에 여러 개의 명령어를 처리할 수 있음
  

- **4. 명령어 병렬 처리 기법을 활용하면 CPU의 처리 속도를 향상시킬 수 있다. O** 
  - CPU 성능을 향상시키는 주요 방법 중 하나
  - 파이프라이닝, 슈퍼스칼라, 멀티코어 같은 기술을 활용하면 성능을 최적화할 수 있음
---

</details>

### Q3. 다음 설명에 해당하는 명령어 병렬 처리 기법으로 알맞은 것은?
- 명령어 파이프라인에서 명령어의 순차적인 처리를 진행하던 중 데이터 위험, 제어 위험과 같은 파이프라인 위험 발생 시, 명령어가 곧바로 처리되지 못해 문제가 발생한다.
- 이러한 문제를 해결하기 위해, 명령어를 순차적으로만 실행하지 않고 그 중 순서를 바꿔 실행해도 문제없는 명령어를 먼저 실행하는 기법을 사용할 수 있다.


#### 1. 분기 예측
#### 2. 슈퍼스칼라
#### 3. 비순차적 명령어 처리
#### 4. 명령어 파이프라이닝

<details>
<summary>정답</summary>

#### 3. 비순차적 명령어 처리   
- 비순차적 명령어 처리는 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리 하지 않고 순서를 바꾸어 처리하는 기법입니다.
- 명령어의 의존성 검사를 통해 실행 가능여부를 판단하고, 의존성이 해결될 때까지 실행되지 못하는 명령어의 실행 대신 해당 시점에 의존성이 없는 명령어를 실행함으로써 명령어 파이프라인이 멈추는 것을 방지할 수 있습니다.

1. 분기 예측 : 파이프라인 위험 중 제어 위험을 방지하기 위해 사용하는 기술로, 프로그램이 어디로 분기할지 미리 예측한 후 해당 분기 주소를 인출합니다.
2. 슈퍼스칼라 : 명령어 병렬 처리를 위해 CPU 내부에 여러 개의 명령어 파이프라인을 구성하는 기법입니다. 
4. 명령어 파이프라이닝 : 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법입니다.
  
---

</details>  


### **Q4. 구조적 위험이 발생하는 주요 원인과 이를 방지할 수 있는 방법은 무엇인가요?**  

<details>  
<summary>정답</summary>  

#### 주요 원인  

- **자원의 한계**  
  - CPU의 자원은 제한적이며, 명령어 실행에 필요한 연산 장치, 메모리 접근 경로, 버스 등의 자원이 충분하지 않을 경우 발생  
  - **설계 자체의 제약으로 인해 특정 자원이 부족할 경우 구조적 위험이 발생할 수 있음**  

- **여러 명령어가 동일한 자원을 동시에 필요로 할 때**  
  - 두 개 이상의 명령어가 동시에 동일한 연산 장치나 메모리에 접근해야 하지만, 해당 자원이 하나뿐이면 일부 명령어는 대기해야 함  
  - **명령어 간 자원 경쟁으로 인해 발생하는 문제**  

- **CPU 내부의 실행 유닛 부족**  
  - CPU가 명령어를 실행하는 유닛(예: ALU, FPU, 메모리 접근 장치 등)이 충분하지 않으면 일부 명령어는 실행할 유닛이 없어 대기해야 함  
  - **슈퍼스칼라 CPU는 다수의 실행 유닛을 활용해 해결할 수 있지만, 단순한 파이프라인 CPU에서는 실행 유닛 부족으로 병목이 발생할 수 있음**  

---

#### 구조적 위험 예방책  

- **고성능 CPU 사용**: 최신 CPU는 실행 유닛 증가, 명령어 스케줄링 최적화, 멀티포트 메모리 설계를 통해 구조적 위험을 최소화할 수 있음  
- **실행 유닛 확장**: 여러 개의 연산 장치와 메모리 접근 포트를 추가하여 동시에 여러 명령어를 실행할 수 있도록 설계  
- **파이프라인 설계 개선**: 파이프라인을 여러 개로 나누는 기법을 적용하여 특정 단계에서 병목이 발생하지 않도록 최적화  
- **캐시 및 멀티포트 메모리 사용**: 자주 사용하는 데이터를 캐시에 저장하여, 메모리 접근 지연으로 인한 구조적 위험을 줄일 수 있도록 개선  

</details>  

---

### **Q5. 비순차적 명령어 처리와 순차적 명령어 처리를 선택할 때 고려해야 할 주요 기준들은 무엇인가요?**  

<details>  
<summary>정답</summary>  

- **명령어 간 독립성이 높은가?**  
  - 독립적인 연산이 많다면 실행 순서를 바꾸어 성능을 최적화 -> 비순차적 명령어 처리  
- **명령어 간 의존성이 높은가?**  
  - 의존성이 높은 연산이 많아 앞선 연산 결과가 다음 연산에 영향을 미치는 경우 -> 순차적 명령어 처리  

- **하드웨어가 복잡한 최적화를 지원하는가?**  
  - 최신 고성능 하드웨어(CPU)는 비순차적 처리를 자동으로 최적화 가능  
  - (예: Out-of-Order Execution, 명령어 재배열, 동적 명령어 스케줄링)  
  - 임베디드 시스템이나 저사양 기기에서는 단순한 순차적 실행이 적절함  

---  

**비순차적 명령어 처리 예시**  
- 멀티미디어 처리 (동영상 인코딩, 3D 그래픽 렌더링)  
- AI 연산 (행렬 연산, 머신러닝 모델 실행)  
- 병렬 처리 최적화가 중요한 게임 및 시뮬레이션  

**순차적 명령어 처리 예시**  
- **임베디드 시스템 (스마트 워치, IoT 센서 데이터 처리)**  
  - 단순 제어 루프를 사용하는 시스템에서는 불필요한 명령어 재배열보다 순차적 처리가 효율적  
- 금융 연산 및 암호화 (결과의 정확성이 중요한 계산)  
- 배터리 기반 기기에서의 연산 (전력 효율성 극대화 필요)  

</details>  

---

### Q6. 다음은 비순차적 명령어 처리를 통해 실행될 수 있는 코드의 일부이다. 코드를 보고 비순차적 명령어 처리 기법을 적용하면 어떤 방식으로 실행되는가?
```markdown
1. R1 ← R2 + R3  (A)
2. R4 ← R5 × R6  (B)
3. R7 ← R1 - R8  (C)
```

<details>
<summary>정답</summary>

<h4>(B) → (A) → (C)</h4>

- **(A)와 (C)는 데이터 의존성이 있기 때문에 (C)는 (A) 이후에 실행해야됨.**
- **하지만 (B)는 독립적인 명령어이므로, (A)보다 먼저 실행가능**


</details>

---


### Q7. 슈퍼스칼라(Superscalar)의 제약 사항으로 옳지 않은 것은?

#### 1️⃣ 데이터 의존성
#### 2️⃣ 자원 의존성
#### 3️⃣ 명령어 독립성
#### 4️⃣ 프로시저 의존성

<details>
<summary>정답</summary>

#### 3️⃣ 명령어 독립성: 명령어 독립성은 슈퍼스칼라의 성능을 향상시키는 요소이므로 제약 사항이 아님.

- 슈퍼스칼라의 제약 사항
    - 데이터 의존성: 명령어들 간에 데이터가 서로 의존적일 경우, 다음 명령어가 앞의 명령어가 끝날 때까지 대기해야 함.
    - 자원 의존성:여러 개의 명령어가 동일한 하드웨어 자원(ALU, FPU 등)을 사용하려고 하면 하나의 명령어는 대기해야 함.
    - 프로시저 의존성:분기 명령어에 의해 생기는 문제로, 분기 명령어와 바로 다음에 있는 명령어는 동시에 실행될 수 없음.

---

</details>

---

### Q8. 명령어 파이프라인에서 단계가 겹치지만 않는다면.. 이라는 문구가 있다. 그러면 겹치면 어떻게 되길래 이렇게 말을 하는걸까?


<details>
<summary>정답</summary>

보통 "명령어 가져오기(Fetch) → 해석(Decode) → 실행(Execute) → 메모리 접근(Memory) → 저장(Write Back)" 같은 단계를 거친다. 하지만 그 단계가 겹치면 크게 3가지의 문제가 생긴다.


1️⃣  구조적 해저드(Structural Hazard)
- CPU 내부 자원을 여러 명령어가 동시에 사용하려고 하면 충돌이 발생한다.
- 예를 들어, 동시에 두 개의 명령어가 같은 메모리를 읽거나 저장하려 하면 문제가 생길 수 있다.  
- 해결 방법: 하드웨어 리소스 증가(예: 여러 개의 ALU, 메모리 캐시 분리 등)  

2️⃣ 데이터 해저드(Data Hazard)
- 하나의 명령어가 결과를 내기 전에, 다음 명령어가 그 결과를 사용하려고 하면 발생하는 문제다.  
- 예시로 ADD 명령어의 결과가 아직 나오지 않았는데, SUB 명령어가 그 값을 사용하려 하면 잘못된 연산이 될 수도 있다.  
- 해결 방법: 포워딩(Forwarding) 또는 스톨(지연, Stall)  

3️⃣ 제어 해저드(Control Hazard, Branch Hazard)
- 분기(branch) 명령어 때문에 다음 명령어가 어떤 걸 실행해야 할지 모를 때 발생한다.
- 예를 들어, if 문 같은 분기문이 있을 때 실행할 코드가 바뀌면 잘못된 명령어를 실행할 수도 있다.  
- 해결 방법: 브랜치 예측(Branch Prediction), 지연 슬롯(Delayed Branching)



</details>

## 📝 사용법  
### 이렇게 활용해 보세요! ✨  
1. ❓ 확인 문제 아래에 본인이 만든 질문을 추가하세요.  
2. 설명이 길어질 경우, 따로 마크다운 파일을 만들고 링크를 함께 추가해 주세요! 🔗  

### 🔗 링크 추가 방법  
1. 먼저 질문을 작성합니다.  
2. 링크를 적용할 문장을 마우스로 선택합니다.  
3. URL을 붙여넣습니다.  
4. 마크다운 형식으로 `[내용](링크)` 형태로 정리됩니다.  
