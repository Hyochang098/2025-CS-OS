# 03-2 명령어의 구조

## 📌 학습 목표
- 해당 챕터의 개념 정리

## ❓ 확인 문제

### Q1. 다음 연산 코드 유형과 해당하는 대표적인 연산 코드를 올바르게 매칭하라.

<연산 코드 유형>

- 데이터 전송
- 산술/논리 연산
- 제어 흐름 변경
- 입출력 제어


< 대표적인 연산 코드 >

- STORE: 데이터를 메모리에 저장하라
- HALT: 프로그램의 실행을 멈춰라
- TEST IO: 입출력 장치의 상태를 확인하라
- INCREMENT: 오퍼랜드에 1을 더하라

<details>
<summary>정답</summary>

| 연산 코드 유형 | 대표적인 연산 코드 | 수행 역할 |
|--------------|----------------|----------|
| **1. 데이터 전송** | **STORE** | 데이터를 CPU에서 메모리로 저장하는 연산 |
| **2. 산술/논리 연산** | **INCREMENT** | 오퍼랜드 값에 1을 더하는 연산 |
| **3. 제어 흐름 변경** | **HALT** | 프로그램의 실행을 멈추고 CPU를 정지 |
| **4. 입출력 제어** | **TEST IO** | 특정 입출력 장치의 현재 상태를 확인 |

---

</details>

### Q2. 현대 CPU의 다양한 주소 지정 방식에 대한 설명으로 옳은 것은?

1️. 간접 주소 지정 방식은 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시한다. 
2️. 레지스터 간접 주소 지정 방식은 두 번의 메모리 접근이 필요하기 때문에 즉시 주소 지정 방식보다 느리다. 
3️. 즉시 주소 지정 방식은 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시한다. 
4️. 직접 주소 지정 방식은 레지스터 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다. 

<details>
<summary>정답</summary>

③ 즉시 주소 지정 방식은 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시한다.

**[해설]**

- **① 간접 주소 지정 방식은 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시한다.**  ❌ 
  - 간접 주소 지정 방식은 **유효 주소의 주소를 오퍼랜드 필드에 명시**하는 방식이다.  
  - 레지스터를 직접 명시하는 방식은 **레지스터 (직접) 주소 지정 방식**이다.  

- **② 레지스터 간접 주소 지정 방식은 두 번의 메모리 접근이 필요하기 때문에 즉시 주소 지정 방식보다 느리다.**  ❌ 
  - 레지스터 간접 주소 지정 방식은 **연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법**으로, 한 번의 메모리 접근만 필요하다.  
  - 두 번의 메모리 접근이 필요하기 때문에 즉시 주소 지정 방식보다 느린 방식은 **간접 주소 지정 방식(메모리 참조 후 추가로 한 번 더 참조)**이다.  
  - 즉시 주소 지정 방식은 데이터가 명령어 자체에 포함되어 있어 메모리 접근이 필요 없으므로 더 빠르다.  

- **③ 즉시 주소 지정 방식은 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시한다.**  ✅ 
  - 즉시 주소 지정 방식(Immediate Addressing Mode)은 **명령어 내 오퍼랜드 필드에 연산할 데이터를 직접 포함**하는 방식이다.  
  - 따라서 **추가적인 메모리 접근이 필요 없으며, 실행 속도가 매우 빠르다.**  
  - 하지만, 명령어 크기 제한으로 인해 저장할 수 있는 데이터 크기에 한계가 있다.  

- **④ 직접 주소 지정 방식은 레지스터 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다.**  ❌ 
  - 직접 주소 지정 방식(Direct Addressing Mode)은 **오퍼랜드 필드에 실제 데이터가 저장된 메모리 주소를 포함하는 방식**이다.  
  - 이 경우 CPU가 **해당 메모리 주소를 참조하여 데이터를 읽어와야 하므로, 메모리에 접근하는 시간이 필요**하다.  
  - 반면, **레지스터 주소 지정 방식(Register Addressing Mode)**은 오퍼랜드를 CPU 내부의 레지스터에서 직접 읽기 때문에 **훨씬 빠르다.**
---

</details>

### Q3. 오퍼랜드에 대한 설명으로 옳지 <U>않은</U> 것은 ?
#### 1️⃣ 연산코드가 연산자라면 오퍼랜드는 피연산자이다.
#### 2️⃣ 오퍼랜드가 담기는 영역인 오퍼랜드 필드는 주소필드라고도 한다.
#### 3️⃣ 하나의 명령어에는 하나 이상의 오퍼랜드가 있어야 한다.
#### 4️⃣ 오퍼랜드 필드에는 연산에 사용할 데이터가 담길 수 있다.
#### 5️⃣ 연산의 대상이 되는 데이터가 저장된 위치를 유효주소라고 한다. 


<details>
<summary>정답</summary>

#### 3️⃣ 하나의 명령어에는 하나 이상의 오퍼랜드가 있어야 한다.

**[해설✏️]**
##### 명령어의 오퍼랜드는 0 - N개를 가질 수 있다. 
##### 오퍼랜드가 하나도 없는 명령어를 0-주소 명령어라고 하고, 오퍼랜드가 하나인 명령어를 1-주소 명령어, 세 개인 명령어를 3-주소 명령어라고 한다. 
##### 오퍼랜드의 개수에 따라서 오퍼랜드 필드 당 할당 가능한 비트의 수가 달리진다. 명령어의 크기가 16비트이고 연산코드 필드가 4비트인 2-주소 명령어에서는 오퍼랜드 필드 당 6비트 정도밖에 남지 않는다. 따라서 여러가지 주소 지정 방식을 사용하여 더 많은 정보를 저장한다. 



</details>


### Q4.기계어와 어셈블리어의 주소 지정방식인 간접 주소 지정방식(Indirect addressing mode)과 레지스터 간접 주소 지정 방식(Register indirect Addressing mode)의 차이점은 무엇인가 ?



<details>
<summary>정답</summary>

#### 간접 주소 지정방식 (Indirect addressing mode)은 유효 주소를 오퍼랜드 필드에 명시하는 반면에, 레지스터 간접 주소 지정방식(Register indirect Addressing mode)는 연산에 사용될 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방식이다. 
#### 레지스터 간접 주소 지정방식은 간접 주소 지정방식과 비슷하지만, 메모리에 접근하는 횟수가 한 번으로 줄어든다는 장점이 있다. 따라서 레지스터 간접 주소 지정방식은  간접 주소 지정방식보다 빠르다.

##### [이헤가 쉬운 그림이 있어요] https://nijy.tistory.com/148



</details>


### Q5. 레지스터 주소 지정 방식과 레지스터 간접 주소 지정 방식에 관련한 설명 중 옳지 않은 것은?

#### 1️⃣ 레지스터 간접 주소 지정 방식이 오퍼랜드 필드에 명시하는 값은 유효 주소를 저장한 레지스터이다.
#### 2️⃣ 레지스터 주소 지정 방식이 오퍼랜드 필드에 명시하는 값은 유효 주소(레지스터 이름)이다.
#### 3️⃣ 레지스터 주소 지정 방식은 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다.
#### 4️⃣ 레지스터 간접 주소 지정 방식은 메모리에 2번 접근한다.

<details>
<summary>정답</summary>

#### 4️⃣ : 레지스터 간접 주소 지정 방식은 메모리에 1번 접근함.
- 레지스터 주소 지정 방식 : 연산에 사용할 데이터를 저장한 레지스터 오퍼랜드 필드에 직접 명시
    - 직접 주소 지정 방식과 다르게 데이터가 레지스터에 존재하기 때문에 속도 빠름
    - 레지스터 수 제한되어 있어 무한정 사용 불가
- 레지스터 간접 주소 지정 방식 : 연산에 사용할 데이터 메모리에 저장하고 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
    - 많은 주소 공간 활용 가능
    - 간접 주소 지정 방식과 다르게 메모리에 1번만 접근하기 때문에 속도 빠름

</details>

### Q6. Java에는 프로그램의 실행흐름을 제어하기 위한 제어문이 있다. 이중 저급 언어로 변환되면 CONDITIONAL JUMP가 동작되는 예약어는 무엇인가?

#### 1. return

#### 2. brake

#### 3. if

#### 4. switch

<details>
<summary>정답</summary>

#### 3, 4

결국 연산 코드는 고급 언어가 변환된 저급 언어의 명령에 관한 내용이다

return 은 RETURN, brake는 JUMP에 대응되며 조건을 확인하고 이 조건에 맞으면 코드 블럭을 실행하는 if문과 switch문이 CONDITIONAL JUMP에 해당한다

</details>

### Q7. 레지스터 주소 지정 방식은 직접 주소 지정 방식보다 빠르다. 그 이유는?

<details>
<summary>정답</summary>

메모리에 접근하는 것보다 CPU 내부의 레지스터에 접근하는 것이 더 빠르기 때문

</details>

### Q8. 즉시 주소 지정 방식은 다른 메모리나 레지스터를 참조하지 않아도 되어 실행 속도가 빠르다 그런데 모든 처리를 즉시 주소 지정 방식으로 사용하지 않는 이유는?

<details>
<summary>정답</summary>

데이터를 표현할 수 있는 bit가 제한적이기 때문

명령어 안에는 오퍼랜드만 기록하는 것이 아니라 연산 코드도 기록되어야 한다. 1-주소 명령어 조차 연산 코드만큼 데이터 기록 공간을 손해보게 되며 오퍼랜드 수가 늘어날 수록 하나의 데이터를 위해 할당할 수 있는 공간은 점점 줄어들게 되기에 모든 명령을 즉시 주소 지정 방식으로 해결 할 수 없다. 

</details>

## 📝 사용법  
### 이렇게 활용해 보세요! ✨  
1. ❓ 확인 문제 아래에 본인이 만든 질문을 추가하세요.  
2. 설명이 길어질 경우, 따로 마크다운 파일을 만들고 링크를 함께 추가해 주세요! 🔗  

### 🔗 링크 추가 방법  
1. 먼저 질문을 작성합니다.  
2. 링크를 적용할 문장을 마우스로 선택합니다.  
3. URL을 붙여넣습니다.  
4. 마크다운 형식으로 `[내용](링크)` 형태로 정리됩니다.  
